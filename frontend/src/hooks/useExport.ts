import { useCallback } from 'react';
import { jsPDF } from 'jspdf';
import type { CrochetPattern } from '../types/pattern';

export const useExport = () => {
  const exportAsJSON = useCallback((pattern: CrochetPattern, filename: string = 'pattern.json') => {
    try {
      const json = JSON.stringify(pattern, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      return { success: true };
    } catch (error) {
      console.error('JSON export error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export JSON',
      };
    }
  }, []);

  const exportAsPDF = useCallback(async (pattern: CrochetPattern, filename: string = 'pattern.pdf') => {
    try {
      const doc = new jsPDF();
      const margin = 20;
      let yPos = margin;

      // 1. Title
      doc.setFontSize(22);
      doc.setTextColor(198, 123, 92); // Terracotta color
      doc.text('Crochet Pattern', margin, yPos);
      yPos += 15;

      // 2. Metadata Section with Clean Formatting
      // Prevents scientific notation (e.g., 3.67e-16) in dimensions
      const d = pattern.metadata.dimensions;
      const dimStr = `${d.width.toFixed(2)}" x ${d.height.toFixed(2)}" x ${d.depth.toFixed(2)}"`;

      doc.setFontSize(12);
      doc.setTextColor(26, 26, 26); // Charcoal
      doc.setFont('helvetica', 'bold');
      doc.text('Pattern Summary', margin, yPos);
      yPos += 7;
      
      doc.setFont('helvetica', 'normal');
      const metaLines = [
        `Total Stitches: ${pattern.metadata.stitchCount}`,
        `Total Rows: ${pattern.metadata.rowCount}`,
        `Estimated Time: ${pattern.metadata.estimatedTime}`,
        `Yarn Required: ${pattern.metadata.yarnEstimate}`,
        `Dimensions: ${dimStr}`
      ];

      metaLines.forEach(line => {
        doc.text(line, margin + 5, yPos);
        yPos += 6;
      });

      // 3. Embed SVG Diagram using Data URL approach
      if (pattern.diagram.svg) {
        yPos += 10;
        doc.setFont('helvetica', 'bold');
        doc.text('Stitch Diagram', margin, yPos);
        yPos += 5;

        try {
          // Convert SVG string to a Base64 Data URL for stable embedding
          const svg64 = btoa(unescape(encodeURIComponent(pattern.diagram.svg)));
          const svgDataUrl = `data:image/svg+xml;base64,${svg64}`;
          
          // Render the vector diagram into the PDF
          doc.addImage(svgDataUrl, 'SVG', margin, yPos, 170, 120); 
          yPos += 130;
        } catch (svgErr) {
          console.warn('Could not embed SVG directly, skipping diagram in PDF:', svgErr);
          doc.setFont('helvetica', 'italic');
          doc.text('[Diagram could not be rendered in PDF]', margin + 5, yPos);
          yPos += 10;
        }
      }

      // 4. Instructions Header
      if (yPos > 250) { // Check for page break
        doc.addPage();
        yPos = margin;
      }
      doc.setFont('helvetica', 'bold');
      doc.text('Instructions', margin, yPos);
      yPos += 8;

      // 5. Row-by-Row Instructions with Pagination
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      
      pattern.instructions.rows.forEach((row) => {
        const rowText = `Row ${row.number}: ${row.stitches.map(s => s.instruction).join(', ')} (${row.totalStitches} sts)`;
        const splitText = doc.splitTextToSize(rowText, 170);
        
        if (yPos + (splitText.length * 5) > 280) {
          doc.addPage();
          yPos = margin;
        }

        doc.text(splitText, margin, yPos);
        yPos += (splitText.length * 5) + 2;
      });

      // 6. Footer (Page numbers)
      const pageCount = (doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text(`Generated by Crochet Pattern Generator - Page ${i} of ${pageCount}`, 105, 290, { align: 'center' });
      }

      doc.save(filename);
      return { success: true };
    } catch (error) {
      console.error('PDF export error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate PDF',
      };
    }
  }, []);

  const exportAsSVG = useCallback((pattern: CrochetPattern, filename: string = 'pattern.svg') => {
    try {
      if (!pattern.diagram.svg) {
        throw new Error('No diagram available in pattern');
      }

      const blob = new Blob([pattern.diagram.svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      return { success: true };
    } catch (error) {
      console.error('SVG export error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export SVG',
      };
    }
  }, []);

  const exportAsCSV = useCallback((pattern: CrochetPattern, filename: string = 'pattern.csv') => {
    try {
      const headers = ['ID', 'Type', 'Row', 'Position X', 'Position Y', 'Position Z', 'Connections'];
      const rows = pattern.stitches.map(stitch => [
        stitch.id,
        stitch.type,
        stitch.row,
        stitch.position3D.x,
        stitch.position3D.y,
        stitch.position3D.z,
        stitch.connections.join(';'),
      ]);

      const csv = [
        headers.join(','),
        ...rows.map(row => row.join(',')),
      ].join('\n');

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      return { success: true };
    } catch (error) {
      console.error('CSV export error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export CSV',
      };
    }
  }, []);

  return {
    exportAsJSON,
    exportAsPDF,
    exportAsSVG,
    exportAsCSV,
  };
};
